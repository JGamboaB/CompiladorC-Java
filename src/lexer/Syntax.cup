package lexer;

import java_cup.runtime.Symbol;

parser code
{:
    private Symbol s;
    
    public void syntax_error(Symbol s){
        this.s = s;
    }

    public Symbol getS(){
        return this.s;
    }
:};

terminal BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, ELSE, FOR, IF,
    INT, LONG, RETURN, SHORT, SWITCH, VOID, WHILE, MAIN, READ, WRITE,
    ID, NUMBERLITERAL, CHARLITERAL, STRING, COMMA, SEMICOLON, COLON,
    EQUAL, SUM, MINUS, MULT, DIV, MOD, RPAR, LPAR, RBRACKET, LBRACKET,
    RBRACES, LBRACES, OPLOGIC, NOT, OPRELATIONAL, OPASSIGNMENT, OPINCDEC;

non terminal program, declList, decl, literal, literalNoStr, idOptions, idExpLiterals, 
    expLiterals, expAssignment, expIncDec, expRegular, expRelationalLogical, expNot,
    expParenthesis, exp, expRegularConstant, expRelationalLogicalConstant, expNotConstant, 
    expParenthesisConstant, expConstant, varDecl, typeVar, varDeclList, varDeclInit, varAssignment, 
    varAssignmentList, funcDecl, typeFunc, parms, parmList, parmTypeList, parmId,
    selectionStmt, switchStmt, iterationStmt, expStmt, stmtList, compoundStmt, instructions, stmt;

start with program;

program ::= declList;

declList ::= declList decl
    | decl
    ;

decl ::= varDecl 
    | funcDecl
    ;

/* EXP ---------------------------------------------------------------------- */

literal ::= NUMBERLITERAL 
    | CHARLITERAL 
    | STRING 
    ;

literalNoStr ::= NUMBERLITERAL 
    | CHARLITERAL
    ;

idOptions ::= ID 
    | ID LBRACKET NUMBERLITERAL RBRACKET 
    | ID LBRACKET CHARLITERAL RBRACKET 
    | ID LBRACKET exp RBRACKET
    ;

idExpLiterals ::= exp 
    | literal 
    | idOptions 
    ;

expLiterals ::= exp 
    | literal 
    ;

expAssignment ::= idOptions EQUAL idExpLiterals 
    | idOptions OPASSIGNMENT idExpLiterals
    ;

expIncDec ::= idOptions OPINCDEC;

expRegular ::= idExpLiterals SUM idExpLiterals 
    | idExpLiterals MINUS idExpLiterals
    | idExpLiterals MULT idExpLiterals 
    | idExpLiterals DIV idExpLiterals 
    | idExpLiterals MOD idExpLiterals
    ;

expRelationalLogical ::= idExpLiterals OPRELATIONAL idExpLiterals 
    | idExpLiterals OPLOGIC idExpLiterals
    ;

expNot ::= NOT idExpLiterals;

expParenthesis ::= LPAR idExpLiterals RPAR;

exp ::= expIncDec 
    | expRegular 
    | expRelationalLogical 
    | expNot 
    | expParenthesis
    ;

expRegularConstant ::= expLiterals SUM expLiterals 
    | expLiterals MINUS expLiterals
    | expLiterals MULT expLiterals 
    | expLiterals DIV expLiterals 
    | expLiterals MOD expLiterals
    ;

expRelationalLogicalConstant ::= expLiterals OPRELATIONAL expLiterals 
    | expLiterals OPLOGIC expLiterals
    ;

expNotConstant ::= NOT expLiterals;

expParenthesisConstant ::= LPAR expLiterals RPAR;

expConstant ::= expRegularConstant 
    | expRelationalLogicalConstant
    | expNotConstant
    | expParenthesisConstant
    ;

/* VARS ---------------------------------------------------------------------- */

varDecl ::= typeVar varDeclList SEMICOLON 
    | CONST typeVar varDeclList SEMICOLON
    ;

typeVar ::= CHAR
    | INT
    | LONG
    | SHORT
    ;

varDeclList ::= varDeclList COMMA varDeclInit
    | varDeclInit
    ;

varDeclInit ::= ID 
    | ID EQUAL varAssignment
    | ID EQUAL LBRACES varAssignmentList RBRACES                                      /*necesario? a={1,2,3}*/
    | ID LBRACKET literalNoStr RBRACKET
    | ID LBRACKET literalNoStr RBRACKET EQUAL LBRACES varAssignmentList RBRACES
    | ID LBRACKET literalNoStr RBRACKET EQUAL LBRACES RBRACES                         /*necesario? a[1]={}*/
    ;

varAssignment ::= literal 
    | idOptions
    | exp
    | expAssignment
    ;

varAssignmentList ::= varAssignmentList COMMA varAssignment
    | varAssignment
    ;

/* FUNCTIONS ----------------------------------------------------------------- */

funcDecl ::= typeFunc ID LPAR parms RPAR LBRACES stmt RBRACES
    | typeFunc ID LPAR RPAR LBRACES stmt RBRACES
    | typeFunc MAIN LPAR parms RPAR LBRACES stmt RBRACES
    | typeFunc MAIN LPAR RPAR LBRACES stmt RBRACES
    ;

typeFunc ::= CHAR
    | INT
    | LONG
    | SHORT
    | VOID
    ;

parms ::= parmList;

parmList ::= parmList COMMA parmTypeList 
    | parmTypeList
    ;

parmTypeList ::= typeVar parmId;

parmId ::= idOptions
    | ID LBRACKET RBRACKET
    ;

selectionStmt::= IF LPAR exp RPAR LBRACES stmt RBRACES
    | IF LPAR exp RPAR LBRACES stmt RBRACES ELSE LBRACES stmt RBRACES
    | SWITCH LPAR exp RPAR LBRACES switchStmt RBRACES
    | SWITCH LPAR literalNoStr RPAR LBRACES switchStmt RBRACES
    ;

switchStmt ::= CASE expConstant COLON stmt
    | CASE literal  COLON stmt
    | DEFAULT COLON stmt
    ;

iterationStmt ::= WHILE LPAR idExpLiterals RPAR LBRACES stmt RBRACES
    | DO LBRACES stmt RBRACES WHILE LPAR idExpLiterals RPAR SEMICOLON
    | FOR LPAR expStmt expStmt RPAR LBRACES stmt RBRACES
    | FOR LPAR expStmt expStmt exp RPAR LBRACES stmt RBRACES
    | FOR LPAR expStmt expStmt expAssignment RPAR LBRACES stmt RBRACES
    ;

expStmt ::= SEMICOLON 
    | exp SEMICOLON 
    | expAssignment SEMICOLON 
    ;

stmtList ::= stmt 
    | stmtList stmt
    ;

compoundStmt ::= LBRACES RBRACES 
    | LBRACES stmtList RBRACES 
    | LBRACES varDecl RBRACES
    | LBRACES varDecl stmtList RBRACES
    ;

instructions ::= READ LPAR RPAR SEMICOLON
    | READ LPAR idOptions RPAR SEMICOLON
    | WRITE LPAR idExpLiterals RPAR SEMICOLON
    | WRITE LPAR expAssignment RPAR SEMICOLON
    | RETURN SEMICOLON
    | RETURN idExpLiterals SEMICOLON
    | RETURN expAssignment SEMICOLON   
    | BREAK SEMICOLON
    | CONTINUE SEMICOLON
    ;

stmt ::= expStmt
    | selectionStmt 
    | iterationStmt
    | compoundStmt
    | instructions
    ;

/*
Preguntas para la profe:
error <- cuando usarlo? dentro de stmt, exp, funcion, etc...?
prioridad de operaciones / orden <--------

*/