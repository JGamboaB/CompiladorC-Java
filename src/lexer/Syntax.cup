package lexer;

import java_cup.runtime.Symbol;

parser code
{:
    private Symbol s;
    
    public void syntax_error(Symbol s){
        this.s = s;
    }

    public Symbol getS(){
        return this.s;
    }
:};

terminal BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, ELSE, FOR, IF,
    INT, LONG, RETURN, SHORT, SWITCH, VOID, WHILE, MAIN, READ, WRITE,
    ID, NUMBERLITERAL, CHARLITERAL, STRING, COMMA, SEMICOLON, COLON,
    EQUAL, SUM, MINUS, MULT, DIV, MOD, RPAR, LPAR, RBRACKET, LBRACKET,
    RBRACES, LBRACES, OPLOGIC, NOT, OPRELATIONAL, OPASSIGNMENT, OPINCDEC, ERROR;

non terminal program, declList, decl, varDecl, typeVar, varDeclList,
    varDeclInit, funcDecl, typeFunc, parms, parmList, parmTypeList, parmId

start with program;

program ::= declList;

declList ::= declList decl
    | decl
    ;

decl ::= varDecl 
    | funcDecl
    ;

/* EXP ---------------------------------------------------------------------- */

literal ::= NUMBERLITERAL 
    | CHARLITERAL 
    | STRING 
    ;

literalNoStr ::= NUMBERLITERAL 
    | CHARLITERAL
    ;

idOptions ::= ID 
    | ID LBRACKET NUMBERLITERAL RBRACKET 
    | ID LBRACKET CHARLITERAL RBRACKET 
    | ID LBRACKET exp RBRACKET
    ;

idExpLiterals ::= exp 
    | literal 
    | idOptions 
    ;

expLiterals ::= exp 
    | literal 
    ;

expAssignment ::= idOptions EQUAL idExpLiterals 
    | idOptions OpAssignment idExpLiterals
    ;

expIncDec ::= idOptions OpIncDec;

expRegular ::= idExpLiterals SUM idExpLiterals 
    | idExpLiterals MINUS idExpLiterals
    | idExpLiterals MULT idExpLiterals 
    | idExpLiterals DIV idExpLiterals 
    | idExpLiterals MOD idExpLiterals
    ;

expRelationalLogical ::= idExpLiterals OPRELATIONAL idExpLiterals 
    | idExpLiterals OPLOGIC idExpLiterals
    ;

expNot ::= NOT idExpLiterals;

expParenthesis ::= LPAR idExpLiterals RPAR;

exp ::= expIncDec 
    | expRegular 
    | expRelationalLogical 
    | expNot 
    | expParenthesis
    ;

expRegularConstant ::= expLiterals SUM expLiterals 
    | expLiterals MINUS expLiterals
    | expLiterals MULT expLiterals 
    | expLiterals DIV expLiterals 
    | expLiterals MOD expLiterals
    ;

expRelationalLogicalConstant ::= expLiterals OPRELATIONAL expLiterals 
    | expLiterals OPLOGIC expLiterals
    ;

expNotConstant ::= NOT expLiterals;

expParenthesisConstant ::= LPAR expLiterals RPAR;

expConstant ::= expRegularConstant 
    | expRelationalLogicalConstant
    | expNotConstant
    | expParenthesisConstant
    ;

/* VARS ---------------------------------------------------------------------- */

varDecl ::= typeVar varDeclList SEMICOLON;

typeVar ::= CHAR
    | INT
    | LONG
    | SHORT
    ;

varDeclList ::= varDeclList COMMA varDeclInit
    | varDeclInit
    ;

varDeclInit ::= ID 
    | ID EQUAL varAssignment
    | ID EQUAL LBRACES varAssignmentList RBRACES                                      /*necesario? a={1,2,3}*/
    | ID LBRACKET literalNoStr RBRACKET
    | ID LBRACKET literalNoStr RBRACKET EQUAL LBRACES varAssignmentList RBRACES
    | ID LBRACKET literalNoStr RBRACKET EQUAL LBRACES RBRACES                         /*necesario? a[1]={}*/
    ;

varAssignment ::= literal 
    | idOptions
    | exp
    | expAssingment
    ;

varAssignmentList ::= varAssignmentList COMMA varAssignment
    | varAssignment
    ;

/* FUNCTIONS ----------------------------------------------------------------- */

funcDecl ::= typeFunc ID LPAR parms RPAR LBRACES stmt RBRACES
    | typeFunc ID LPAR RPAR LBRACES stmt RBRACES
    ;

typeFunc ::= CHAR
    | INT
    | LONG
    | SHORT
    | VOID
    ;

parms ::= parmList;

parmList ::= parmList COMMA parmTypeList 
    | parmTypeList
    ;

parmTypeList ::= typeVar parmId;

parmId ::= idOptions
    | ID LBRACKET RBRACKET
    ;

selectionStmt::= IF LPAR exp RPAR LBRACES stmt RBRACES
    | IF LPAR exp RPAR LBRACES stmt RBRACES ELSE LBRACES stmt RBRACES
    | SWITCH LPAR exp RPAR LBRACES switchStmt RBRACES
    | SWITCH LPAR literalNoStr RPAR LBRACES switchStmt RBRACES
    ;

switchStmt ::= CASE expConstant COLON stmt
    | CASE literal  COLON stmt
    | DEFAULT COLON stmt
    ;

iterationStmt ::= WHILE LPAR idExpLiterals RPAR LBRACES stmt RBRACES
    | DO LBRACES stmt RBRACES WHILE LPAR idExpLiterals RPAR SEMICOLON
    | FOR LPAR expressionStmt expressionStmt RPAR LBRACES stmt RBRACES
    | FOR LPAR expressionStmt expressionStmt exp RPAR LBRACES stmt RBRACES
    | FOR LPAR expressionStmt expressionStmt expAssignment RPAR LBRACES stmt RBRACES
    ;

expressionStmt ::= SEMICOLON 
    | exp SEMICOLON 
    | expAssignment SEMICOLON 
    ;

stmt ::= exp SEMICOLON 
    | expAssignment SEMICOLON 
    | selectionStmt 
    ;

// stmt <-
// -> read, write
// keywords dentro de funciones

